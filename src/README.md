## Cодержание

1. [Отчет по лабораторной работе № 2](#отчет-по-лабораторной-работе--n)

## Отчет по лабораторной работе № N

#### № группы: `Ваш № группы: 2`

#### Выполнил: `Корень Егор Романович`

#### Вариант: `13`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Математическая модель](#25-математическая-модель)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

- Условия задачи

> Напишите программу на Java, которая выполняет следующие действия
с трёхмерным массивом дробных чисел:
>1. Считывает с консоли размеры массива X, Y и Z, затем элементы
   массива размером X × Y × Z.
>2. В каждом столбце (фиксируя координаты Y Z) сортирует элементы
   по убыванию их дробной части. Если дробные части равны, сорти-
   рует по возрастанию целой части.
>3. Находит и выводит среднее геометрическое элементов каждого слоя
   (по координатам X и Y ).
>4. Выводит элементы массива - (x, y, z : значение).
>5. Округляет все элементы массива до двух знаков после запятой и
   выводит обновлённый массив.

- Требуется отсортировать столбцы массива по убыванию дробной части, если дробные части равны то по целой части.
- Так как требуется находить среднее геометрическое каждого слоя, то будем считать, что все элементы массива положительные.
- 
### 2. Входные и выходные данные
На вход подаются размеры массива, элементы массива

|                 | Тип                | min значение | max значение   |
|-----------------|--------------------|----------|----------------|
| X               | Целое число        | 1        | 10<sup>9</sup> |
| Y               | Целое число        | 1        | 10<sup>9</sup> |
| Z               | Целое число        | 1        | 10<sup>9</sup> |
| Элемент массива | Вещественное число | 4.9e-324         | 1.7976931348623157e+308 |

Выход: элементы массива и ср. геометрическое

|                        | Тип                | min значение | max значение   |
|------------------------|--------------------|----------|----------------|
| Элемент массива        | Вещественное число |         4.9e-324 | 1.7976931348623157e+308 |
| Среднее геометрическое | Вещественное число |         4.9e-324 | 1.7976931348623157e+308 |

### 3. Выбор структуры данных
Размеры массива `x, y, z`, которые имеют тип данных `int`, трехмерный массив `arr`, имеющий тип данных `double`, `boolean` флаг `swapped`, `double` `temp` - временная переменная

|  | название переменной | Тип (в Java)   | 
|--|---------------------|----------------|
| X | `x`                 | `double`       |
| Y | `y`                 | `double`       | 
| Z | `z`                 | `double`       | 
|  | `arr`               | `array double` | 
|  | `temp`              | `double`       | 
|   | `swapped`           | `boolean`      | 



### 4. Алгоритм

Считывает элементы массива, проходится 3 вложенными циклами для сортировки массива.
Используется сортировка "пузырьком" по убыванию дробной части, если дробные части равны,
то по возрастанию целой. Находим сренднее геометрическое каждого слоя, проходясь 3 циклами по массиву.
Далее округляем каждый элемент до 2 знаков  после запятой.


### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args){
        int x, y, z;
        // пользователь вводит элементы пока они не станут корректными
        do {
            out.println("Введите корректные размеры массива (x, y, z)");
            x = in.nextInt();
            y = in.nextInt();
            z = in.nextInt();
        }
        while(x < 1 || y < 1 || z < 1);

        double[][][] arr = new double[z][y][x];
        out.println("Введите элементы массива");
        // вводим элементы массива
        for(int i = 0; i < z; i++){
            for (int j = 0; j < y; j++){
                for (int k = 0; k < x; k++){
                    arr[i][j][k] = in.nextDouble();
                }
            }
        }
        // перебираем элементы массива, фиксируем arr[i][j] и сортируем его элементы
        for(int i = 0; i < z; i++){
            for (int j = 0; j < y; j++){
                // сортировка
                double temp;
                for (int a = 0; a < x * 2; a++){ // x * 2 потому что после сортировки по дробной части x могло не хватать и оставались неотсортированные по целой части числа;
                    boolean swapped = false; // ни одна пара элементов не поменялась
                    for(int b = 0; b < x - 1;b++){
                        // если дробная часть arr[i][j][b] больше arr[i][[j][b] или дробные части равны и arr[i][j][b] больше arr[i][j][b + 1]
                        if (arr[i][j][b] % 1 < arr[i][j][b + 1] % 1 || arr[i][j][b] % 1 == arr[i][j][b + 1] % 1 && arr[i][j][b] > arr[i][j][b + 1]){
                            // меняем их местами
                            temp = arr[i][j][b + 1];
                            arr[i][j][b + 1] = arr[i][j][b];
                            arr[i][j][b] = temp;
                            swapped = true; //  пара элементов поменялась местами
                        }
                    }
                    if (!swapped){ // если ни одна пара элементов не поменялась местами, то завершаем цикл
                        break;
                    }
                }
            }
        }
        // находим среднее геометрическое каждого слоя
        for (int i = 0; i < z; i++){  // фиксируем массив по z
            double geom = 1; // среднее геометрическое
            for (int j = 0; j < y; j++){
                for(int k = 0; k < x; k++){
                    geom *= arr[i][j][k]; // перемножаем все элементы слоя
                }
            }
            geom = Math.pow(geom, 1/(double)(x*y)); // берем от geom корень степни x*y (количество элементов в слое)
            out.println(geom);
        }
        // вывод массива
        for (int i = 0; i < z; i++){
            for (int j = 0; j < y; j++){
                for (int k = 0; k < x; k++){
                    out.printf("%d, %d, %d : %f\n", k, j, i, arr[i][j][k]);
                }
            }
        }
        // проходимся по всем элементам массива
        for(int i = 0; i < z; i++){
            for (int j = 0; j < y; j++){
                for (int k = 0; k < x; k++){
                    arr[i][j][k] = (double)Math.round(arr[i][j][k] * 100d) / 100d; // округляем до 2 знаков после запятой
                }
            }
        }
        out.println(); // разделение между выводами массивов
        // вывод массива после округления
        for (int i = 0; i < z; i++){
            for (int j = 0; j < y; j++){
                for (int k = 0; k < x; k++){
                    out.print(arr[i][j][k] + " ");
                }
                out.println(); // разделение строк
            }
            out.println(); // разделение слоев
        }
    }
}


```

### 6. Анализ правильности решения

1. В столбце (z=0, y = 0) 2 числа с одинаковой дробной частью

- Input:
    ```
    3 3 3
  10.6 3.8 4.8
  22.1 41.2 10.8
  31.4 16.02 34.5
  40.3 46.5 5.1
  11.6 17.4 23.03
  48.1 28.3 5.99
  48.3 37.7 10.5
  33.06 35.8 11.2
  33.1 5.2 11.7
    ```

- Output:
````
14.747460593601126
19.24562259161214
19.992985595145097
0, 0, 0 : 3.800000
1, 0, 0 : 4.800000
2, 0, 0 : 10.600000
0, 1, 0 : 10.800000
1, 1, 0 : 41.200000
2, 1, 0 : 22.100000
0, 2, 0 : 34.500000
1, 2, 0 : 31.400000
2, 2, 0 : 16.020000
0, 0, 1 : 46.500000
1, 0, 1 : 40.300000
2, 0, 1 : 5.100000
0, 1, 1 : 11.600000
1, 1, 1 : 17.400000
2, 1, 1 : 23.030000
0, 2, 1 : 5.990000
1, 2, 1 : 28.300000
2, 2, 1 : 48.100000
0, 0, 2 : 37.700000
1, 0, 2 : 10.500000
2, 0, 2 : 48.300000
0, 1, 2 : 35.800000
1, 1, 2 : 11.200000
2, 1, 2 : 33.060000
0, 2, 2 : 11.700000
1, 2, 2 : 5.200000
2, 2, 2 : 33.100000

3.8 4.8 10.6 
10.8 41.2 22.1 
34.5 31.4 16.02 

46.5 40.3 5.1 
11.6 17.4 23.03 
5.99 28.3 48.1 

37.7 10.5 48.3 
35.8 11.2 33.06 
11.7 5.2 33.1
````
2. Три одинаковых дробных части в 1 столбце, в 3 столбце 2 числа с одинаковой дробной частью и одно с другой
- Input:
    ```
    3 2 2
    3.1 7.1 5.1
    22.4 21.6 11.1
    5.987654 4.1414 15.987654
    0.9 1.1 5.4
  ```

- Output:
    ```
  9.191135339822857
    3.5840131556965753
    0, 0, 0 : 3.100000
    1, 0, 0 : 5.100000
    2, 0, 0 : 7.100000
    0, 1, 0 : 21.600000
    1, 1, 0 : 22.400000
    2, 1, 0 : 11.100000
    0, 0, 1 : 5.987654
    1, 0, 1 : 15.987654
    2, 0, 1 : 4.141400
    0, 1, 1 : 0.900000
    1, 1, 1 : 5.400000
    2, 1, 1 : 1.100000
    
    3.1 5.1 7.1
    21.6 22.4 11.1
    
    5.99 15.99 4.14
    0.9 5.4 1.1 
```
